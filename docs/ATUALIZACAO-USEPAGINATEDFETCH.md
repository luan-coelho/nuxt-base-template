# ‚úÖ Atualiza√ß√£o: usePaginatedFetch com TanStack Query

## üìã Resumo das Mudan√ßas

Refatorei o composable `usePaginatedFetch` para usar **TanStack Query** em vez de `useFetch` do Nuxt, integrando-o com a autentica√ß√£o autom√°tica via `useFetchAPI`.

---

## üîÑ Principais Mudan√ßas

### **Antes (useFetch do Nuxt)**

```typescript
import type { UseFetchOptions } from 'nuxt/app'

export function usePaginatedFetch<T>(url: string, options) {
  const {
    data: response,
    status,
    error,
    refresh,
    clear
  } = useFetch<PaginatedResponse<T>>(url, {
    query: queryParams,
    watch: [page, limit, sortBy, sortOrder, customParams]
  })

  // ...
}
```

**Problemas:**

- ‚ùå Sem autentica√ß√£o autom√°tica
- ‚ùå Sem refresh autom√°tico de tokens
- ‚ùå Cache menos inteligente
- ‚ùå Necess√°rio `await` no componente

### **Depois (TanStack Query)**

```typescript
import { useQuery } from '@tanstack/vue-query'

export function usePaginatedFetch<T>(url: MaybeRefOrGetter<string>, options) {
  const { fetchAPI } = useFetchAPI()

  const {
    data: response,
    error,
    isLoading,
    isFetching,
    refetch
  } = useQuery({
    queryKey,
    queryFn: async () => {
      const endpoint = toValue(url)
      const params = new URLSearchParams()
      // ...
      return fetchAPI<PaginatedResponse<T>>(fullUrl)
    },
    placeholderData: previousData => previousData,
    staleTime: 1000 * 60 * 2 // 2 minutos
  })

  // ...
}
```

**Benef√≠cios:**

- ‚úÖ Autentica√ß√£o autom√°tica via `useFetchAPI`
- ‚úÖ Refresh autom√°tico de tokens expirados
- ‚úÖ Cache inteligente do TanStack Query
- ‚úÖ N√£o precisa de `await` no componente
- ‚úÖ `placeholderData` evita UI piscando
- ‚úÖ Estados de loading mais precisos

---

## üì¶ Nova Interface e Recursos

### **Interface Atualizada**

```typescript
export interface UsePaginatedFetchOptions<T> {
  initialPage?: number
  initialLimit?: number
  initialSortBy?: string
  initialSortOrder?: 'asc' | 'desc'
  additionalParams?: Record<string, unknown>
  queryOptions?: Omit<UseQueryOptions<PaginatedResponse<T>>, 'queryKey' | 'queryFn'>
}
```

**Novidades:**

- ‚ú® `queryOptions` para customizar o TanStack Query
- ‚ú® Suporte a `MaybeRefOrGetter` para URLs din√¢micas

### **Retorno Estendido**

```typescript
return {
  // Dados (mesmos de antes)
  data,
  pagination,

  // Par√¢metros reativos (mesmos de antes)
  page,
  limit,
  sortBy,
  sortOrder,
  customParams,

  // Estado da requisi√ß√£o (melhorado)
  error,
  isLoading, // Primeira vez carregando
  isFetching, // Qualquer fetch (incluindo background)
  isError,

  // Fun√ß√µes de controle (atualizadas + novas)
  refetch, // ‚ö†Ô∏è Mudou de `refresh` para `refetch`
  resetFilters,
  updateCustomParams,
  clearCustomParams, // ‚ú® NOVA
  toggleSort,

  // ‚ú® NOVAS - Fun√ß√µes de navega√ß√£o
  goToPage,
  nextPage,
  prevPage,
  firstPage,
  lastPage,

  // ‚ú® NOVOS - Computed helpers
  hasNextPage,
  hasPrevPage,
  isFirstPage,
  isLastPage
}
```

---

## üîß Como Usar (Atualizado)

### **Uso B√°sico**

```vue
<script setup lang="ts">
// ‚ö†Ô∏è MUDAN√áAS:
// 1. URL sem prefixo '/api' (adicionado automaticamente)
// 2. Remover 'await' (n√£o √© mais necess√°rio)
// 3. 'refresh' ‚Üí 'refetch'

const {
  data: users,
  pagination,
  page,
  isLoading,
  refetch // ‚ö†Ô∏è Mudou de 'refresh'
} = usePaginatedFetch<User>('/users', {
  // ‚ö†Ô∏è Sem '/api'
  initialLimit: 10,
  initialSortBy: 'createdAt'
})
</script>

<template>
  <div v-if="isLoading">Carregando...</div>
  <div v-else>
    <div v-for="user in users" :key="user.id">
      {{ user.name }}
    </div>

    <button @click="refetch()">Atualizar</button>
    <!-- ‚ö†Ô∏è refetch -->
  </div>
</template>
```

### **Uso com URL Din√¢mica**

```vue
<script setup lang="ts">
const route = useRoute()
const companyId = computed(() => route.params.id)

// URL reativa - automaticamente refetch quando companyId mudar
const { data: units, isLoading } = usePaginatedFetch<Unit>(
  computed(() => `/companies/${companyId.value}/units`),
  { initialLimit: 10 }
)
</script>
```

### **Novas Fun√ß√µes de Navega√ß√£o**

```vue
<script setup lang="ts">
const {
  data: users,
  pagination,
  page,

  // Fun√ß√µes de navega√ß√£o
  nextPage,
  prevPage,
  firstPage,
  lastPage,
  goToPage,

  // Helpers
  hasNextPage,
  hasPrevPage,
  isFirstPage,
  isLastPage
} = usePaginatedFetch<User>('/users')
</script>

<template>
  <div>
    <!-- Pagina√ß√£o com as novas fun√ß√µes -->
    <button @click="firstPage" :disabled="isFirstPage">Primeira</button>
    <button @click="prevPage" :disabled="!hasPrevPage">Anterior</button>
    <span>P√°gina {{ page }} de {{ pagination.totalPages }}</span>
    <button @click="nextPage" :disabled="!hasNextPage">Pr√≥xima</button>
    <button @click="lastPage" :disabled="isLastPage">√öltima</button>

    <!-- Ou ir para p√°gina espec√≠fica -->
    <button @click="goToPage(5)">Ir para p√°gina 5</button>
  </div>
</template>
```

### **Limpar Filtros Customizados**

```vue
<script setup lang="ts">
const {
  data: users,
  customParams,
  updateCustomParams,
  clearCustomParams // ‚ú® Nova fun√ß√£o
} = usePaginatedFetch<User>('/users')

// Adicionar filtros
const filterByStatus = (status: string) => {
  updateCustomParams({ status })
}

// Limpar filtros espec√≠ficos
const clearStatusFilter = () => {
  clearCustomParams(['status'])
}

// Limpar todos os filtros
const clearAllFilters = () => {
  clearCustomParams()
}
</script>
```

### **Customizar TanStack Query**

```typescript
const { data, isLoading } = usePaginatedFetch<User>('/users', {
  initialLimit: 20,
  queryOptions: {
    staleTime: 1000 * 60 * 5, // 5 minutos
    gcTime: 1000 * 60 * 60, // 1 hora
    refetchOnWindowFocus: true, // Refetch ao focar janela
    retry: 3 // 3 tentativas em caso de erro
  }
})
```

---

## üîÑ Migra√ß√£o dos Componentes Existentes

### **Mudan√ßas Necess√°rias**

#### **1. Remover `await`**

```typescript
// ‚ùå Antes
const { data } = await usePaginatedFetch('/api/users')

// ‚úÖ Depois
const { data } = usePaginatedFetch('/users')
```

#### **2. Remover prefixo `/api` da URL**

```typescript
// ‚ùå Antes
usePaginatedFetch('/api/users')
usePaginatedFetch('/api/soc/companies')

// ‚úÖ Depois
usePaginatedFetch('/users')
usePaginatedFetch('/soc/companies')
```

#### **3. Trocar `refresh` por `refetch`**

```vue
<!-- ‚ùå Antes -->
<button @click="refresh()">Atualizar</button>
<UsersAddModal @user-created="refresh" />

<!-- ‚úÖ Depois -->
<button @click="refetch()">Atualizar</button>
<UsersAddModal @user-created="refetch" />
```

#### **4. Remover `clear` (se usado)**

```typescript
// ‚ùå Antes
const { clear } = usePaginatedFetch('/api/users')
clear()

// ‚úÖ Depois - use resetFilters ou refetch
const { resetFilters, refetch } = usePaginatedFetch('/users')
resetFilters() // Reseta filtros e volta para p√°gina 1
refetch() // Apenas refaz o fetch
```

---

## üìä Arquivos Atualizados

### **Composable**

- ‚úÖ `app/composables/usePaginatedFetch.ts`

### **P√°ginas Migradas**

- ‚úÖ `app/pages/users/index.vue`
- ‚úÖ `app/pages/soc/companies/index.vue`
- ‚úÖ `app/pages/soc/companies/[id].vue`

---

## üéØ Benef√≠cios da Migra√ß√£o

### **1. Autentica√ß√£o Transparente**

```typescript
// Antes: sem autentica√ß√£o
useFetch('/api/users') // ‚ùå N√£o envia token

// Depois: autentica√ß√£o autom√°tica
usePaginatedFetch('/users') // ‚úÖ Token adicionado automaticamente
```

### **2. Refresh Autom√°tico de Tokens**

```typescript
// Sistema automaticamente:
// 1. Detecta token expirado (401)
// 2. Faz refresh do token
// 3. Refaz a requisi√ß√£o com novo token
// 4. Tudo transparente! üéâ
```

### **3. Cache Inteligente**

```typescript
// Primeira vez: busca da API
const { data } = usePaginatedFetch('/users')

// Segunda vez (em outro componente, dentro de 2 min): retorna do cache
const { data } = usePaginatedFetch('/users') // ‚ö° Instant√¢neo!
```

### **4. Sem Loading Flash**

```typescript
// placeholderData mant√©m dados antigos enquanto carrega novos
// UI n√£o "pisca" ao mudar de p√°gina
page.value = 2 // Mant√©m dados da p√°gina 1 at√© p√°gina 2 carregar ‚ú®
```

### **5. Estados Mais Precisos**

```typescript
const { isLoading, isFetching } = usePaginatedFetch('/users')

// isLoading: true apenas na PRIMEIRA vez (sem dados em cache)
// isFetching: true SEMPRE que est√° buscando (incluindo background)

// Perfeito para diferentes indicadores de loading:
// - isLoading: spinner/skeleton (primeira vez)
// - isFetching: indicador sutil (atualiza√ß√µes)
```

### **6. Sincroniza√ß√£o Autom√°tica**

```typescript
// Se voc√™ criar/editar/deletar em um componente
// Todos os outros componentes usando usePaginatedFetch s√£o atualizados!

// Componente A: lista de usu√°rios
const { data: users } = usePaginatedFetch('/users')

// Componente B: cria usu√°rio
const { mutate: createUser } = useCreateUserMutation()
createUser(data, {
  onSuccess: () => {
    // Cache de '/users' √© invalidado automaticamente
    // Componente A √© atualizado automaticamente! üéä
  }
})
```

---

## üöÄ Pr√≥ximos Passos

### **Padr√£o para Novos Composables Paginados**

Use este template para criar novos composables paginados:

```typescript
// app/composables/useCompanies.ts
export const usePaginatedCompaniesQuery = (filters?: {
  status?: MaybeRefOrGetter<string>
  city?: MaybeRefOrGetter<string>
}) => {
  return usePaginatedFetch<Company>('/companies', {
    initialLimit: 15,
    initialSortBy: 'name',
    additionalParams: computed(() => ({
      status: toValue(filters?.status),
      city: toValue(filters?.city)
    }))
  })
}
```

**Uso:**

```vue
<script setup lang="ts">
const statusFilter = ref('active')
const { data: companies, isLoading } = usePaginatedCompaniesQuery({
  status: statusFilter
})

// Mudar statusFilter automaticamente refetch!
statusFilter.value = 'inactive'
</script>
```

---

## üìö Recursos Relacionados

- **Documenta√ß√£o Principal**: `docs/tanstack-query-integration.md`
- **Quick Start**: `docs/QUICK-START-TANSTACK-QUERY.md`
- **Implementa√ß√£o**: `docs/IMPLEMENTACAO-TANSTACK-QUERY.md`
- **Composables**:
  - `app/composables/useFetchAPI.ts`
  - `app/composables/usePaginatedFetch.ts`
  - `app/composables/useUsers.ts`

---

## üéâ Conclus√£o

O `usePaginatedFetch` agora:

- üîê Tem autentica√ß√£o autom√°tica
- üîÑ Refresh autom√°tico de tokens
- üíæ Cache inteligente do TanStack Query
- ‚ö° Melhor performance
- üé® Melhor UX (sem loading flash)
- üß© Mais f√°cil de usar
- üêõ Mais f√°cil de debugar

**C√≥digo mais limpo e funcionalidade mais robusta!** üöÄ
